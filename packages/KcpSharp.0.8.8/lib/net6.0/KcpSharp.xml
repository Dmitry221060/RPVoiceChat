<?xml version="1.0"?>
<doc>
    <assembly>
        <name>KcpSharp</name>
    </assembly>
    <members>
        <member name="T:KcpSharp.IKcpBufferPool">
            <summary>
            The buffer pool to rent buffers from.
            </summary>
        </member>
        <member name="M:KcpSharp.IKcpBufferPool.Rent(KcpSharp.KcpBufferPoolRentOptions)">
            <summary>
            Rent a buffer using the specified options.
            </summary>
            <param name="options">The options used to rent this buffer.</param>
            <returns></returns>
        </member>
        <member name="T:KcpSharp.IKcpConversation">
            <summary>
            A conversation or a channel over the transport.
            </summary>
        </member>
        <member name="M:KcpSharp.IKcpConversation.InputPakcetAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Put message into the receive queue of the channel.
            </summary>
            <param name="packet">The packet content with the optional conversation ID. This buffer should not contain space for pre-buffer and post-buffer.</param>
            <param name="cancellationToken">The token to cancel this operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> that completes when the packet is put into the receive queue.</returns>
        </member>
        <member name="M:KcpSharp.IKcpConversation.SetTransportClosed">
            <summary>
            Mark the underlying transport as closed. Abort all active send or receive operations.
            </summary>
        </member>
        <member name="T:KcpSharp.IKcpExceptionProducer`1">
            <summary>
            An instance that can produce exceptions in background jobs.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
        </member>
        <member name="M:KcpSharp.IKcpExceptionProducer`1.SetExceptionHandler(System.Func{System.Exception,`0,System.Object,System.Boolean},System.Object)">
            <summary>
            Set the handler to invoke when exception is thrown. Return true in the handler to ignore the error and continue running. Return false in the handler to abort the operation.
            </summary>
            <param name="handler">The exception handler.</param>
            <param name="state">The state object to pass into the exception handler.</param>
        </member>
        <member name="T:KcpSharp.IKcpMultiplexConnection">
            <summary>
            Multiplex many channels or conversations over the same transport.
            </summary>
        </member>
        <member name="M:KcpSharp.IKcpMultiplexConnection.Contains(System.Int32)">
            <summary>
            Determine whether the multiplex connection contains a conversation with the specified id.
            </summary>
            <param name="id">The conversation ID.</param>
            <returns>True if the multiplex connection contains the specified conversation. Otherwise false.</returns>
        </member>
        <member name="M:KcpSharp.IKcpMultiplexConnection.CreateRawChannel(System.Int32,KcpSharp.KcpRawChannelOptions)">
            <summary>
            Create a raw channel with the specified conversation ID.
            </summary>
            <param name="id">The conversation ID.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpRawChannel"/>.</param>
            <returns>The raw channel created.</returns>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Another channel or conversation with the same ID was already registered.</exception>
        </member>
        <member name="M:KcpSharp.IKcpMultiplexConnection.CreateConversation(System.Int32,KcpSharp.KcpConversationOptions)">
            <summary>
            Create a conversation with the specified conversation ID.
            </summary>
            <param name="id">The conversation ID.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpConversation"/>.</param>
            <returns>The KCP conversation created.</returns>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Another channel or conversation with the same ID was already registered.</exception>
        </member>
        <member name="M:KcpSharp.IKcpMultiplexConnection.RegisterConversation(KcpSharp.IKcpConversation,System.Int32)">
            <summary>
            Register a conversation or channel with the specified conversation ID and user state.
            </summary>
            <param name="conversation">The conversation or channel to register.</param>
            <param name="id">The conversation ID.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="conversation"/> is not provided.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Another channel or conversation with the same ID was already registered.</exception>
        </member>
        <member name="M:KcpSharp.IKcpMultiplexConnection.UnregisterConversation(System.Int32)">
            <summary>
            Unregister a conversation or channel with the specified conversation ID.
            </summary>
            <param name="id">The conversation ID.</param>
            <returns>The conversation unregistered. Returns null when the conversation with the specified ID is not found.</returns>
        </member>
        <member name="T:KcpSharp.IKcpMultiplexConnection`1">
            <summary>
            Multiplex many channels or conversations over the same transport.
            </summary>
        </member>
        <member name="M:KcpSharp.IKcpMultiplexConnection`1.CreateRawChannel(System.Int32,`0,KcpSharp.KcpRawChannelOptions)">
            <summary>
            Create a raw channel with the specified conversation ID.
            </summary>
            <param name="id">The conversation ID.</param>
            <param name="state">The user state of this channel.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpRawChannel"/>.</param>
            <returns>The raw channel created.</returns>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Another channel or conversation with the same ID was already registered.</exception>
        </member>
        <member name="M:KcpSharp.IKcpMultiplexConnection`1.CreateConversation(System.Int32,`0,KcpSharp.KcpConversationOptions)">
            <summary>
            Create a conversation with the specified conversation ID.
            </summary>
            <param name="id">The conversation ID.</param>
            <param name="state">The user state of this conversation.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpConversation"/>.</param>
            <returns>The KCP conversation created.</returns>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Another channel or conversation with the same ID was already registered.</exception>
        </member>
        <member name="M:KcpSharp.IKcpMultiplexConnection`1.RegisterConversation(KcpSharp.IKcpConversation,System.Int32,`0)">
            <summary>
            Register a conversation or channel with the specified conversation ID and user state.
            </summary>
            <param name="conversation">The conversation or channel to register.</param>
            <param name="id">The conversation ID.</param>
            <param name="state">The user state</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="conversation"/> is not provided.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Another channel or conversation with the same ID was already registered.</exception>
        </member>
        <member name="M:KcpSharp.IKcpMultiplexConnection`1.UnregisterConversation(System.Int32,`0@)">
            <summary>
            Unregister a conversation or channel with the specified conversation ID.
            </summary>
            <param name="id">The conversation ID.</param>
            <param name="state">The user state.</param>
            <returns>The conversation unregistered with the user state. Returns default when the conversation with the specified ID is not found.</returns>
        </member>
        <member name="T:KcpSharp.IKcpTransport">
            <summary>
            A transport to send and receive packets.
            </summary>
        </member>
        <member name="M:KcpSharp.IKcpTransport.SendPacketAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Send a packet into the transport.
            </summary>
            <param name="packet">The content of the packet.</param>
            <param name="cancellationToken">A token to cancel this operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> that completes when the packet is sent.</returns>
        </member>
        <member name="T:KcpSharp.IKcpTransport`1">
            <summary>
            A transport instance for upper-level connections.
            </summary>
            <typeparam name="T">The type of the upper-level connection.</typeparam>
        </member>
        <member name="P:KcpSharp.IKcpTransport`1.Connection">
            <summary>
            Get the upper-level connection instace. If Start is not called or the transport is closed, <see cref="T:System.InvalidOperationException"/> will be thrown.
            </summary>
            <exception cref="T:System.InvalidOperationException">Start is not called or the transport is closed.</exception>
        </member>
        <member name="M:KcpSharp.IKcpTransport`1.Start">
            <summary>
            Create the upper-level connection and start pumping packets from the socket to the upper-level connection.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="M:KcpSharp.IKcpTransport`1.Start"/> has been called before.</exception>
        </member>
        <member name="T:KcpSharp.KcpBufferPoolRentOptions">
            <summary>
            The options to use when renting buffers from the pool.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpBufferPoolRentOptions.Size">
            <summary>
            The minimum size of the buffer.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpBufferPoolRentOptions.IsOutbound">
            <summary>
            True if the buffer may be passed to the outside of KcpSharp. False if the buffer is only used internally in KcpSharp.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpBufferPoolRentOptions.#ctor(System.Int32,System.Boolean)">
            <summary>
            Create a <see cref="T:KcpSharp.KcpBufferPoolRentOptions"/> with the specified parameters.
            </summary>
            <param name="size">The minimum size of the buffer.</param>
            <param name="isOutbound">True if the buffer may be passed to the outside of KcpSharp. False if the buffer is only used internally in KcpSharp.</param>
        </member>
        <member name="M:KcpSharp.KcpBufferPoolRentOptions.Equals(KcpSharp.KcpBufferPoolRentOptions)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpBufferPoolRentOptions.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpBufferPoolRentOptions.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:KcpSharp.KcpConversation">
            <summary>
            A reliable channel over an unreliable transport implemented in KCP protocol.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpConversation.#ctor(KcpSharp.IKcpTransport,KcpSharp.KcpConversationOptions)">
            <summary>
            Construct a reliable channel using KCP protocol.
            </summary>
            <param name="transport">The underlying transport.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpConversation"/>.</param>
        </member>
        <member name="M:KcpSharp.KcpConversation.#ctor(KcpSharp.IKcpTransport,System.Int32,KcpSharp.KcpConversationOptions)">
            <summary>
            Construct a reliable channel using KCP protocol.
            </summary>
            <param name="transport">The underlying transport.</param>
            <param name="conversationId">The conversation ID.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpConversation"/>.</param>
        </member>
        <member name="M:KcpSharp.KcpConversation.SetExceptionHandler(System.Func{System.Exception,KcpSharp.KcpConversation,System.Object,System.Boolean},System.Object)">
            <summary>
            Set the handler to invoke when exception is thrown during flushing packets to the transport. Return true in the handler to ignore the error and continue running. Return false in the handler to abort the operation and mark the transport as closed.
            </summary>
            <param name="handler">The exception handler.</param>
            <param name="state">The state object to pass into the exception handler.</param>
        </member>
        <member name="P:KcpSharp.KcpConversation.ConversationId">
            <summary>
            Get the ID of the current conversation.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversation.TransportClosed">
            <summary>
            Get whether the transport is marked as closed.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversation.StreamMode">
            <summary>
            Get whether the conversation is in stream mode.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpConversation.TryGetSendQueueAvailableSpace(System.Int32@,System.Int32@)">
            <summary>
            Get the available byte count and available segment count in the send queue.
            </summary>
            <param name="byteCount">The available byte count in the send queue.</param>
            <param name="segmentCount">The available segment count in the send queue.</param>
            <returns>True if the transport is not closed. Otherwise false.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.TrySend(System.ReadOnlySpan{System.Byte})">
            <summary>
            Try to put message into the send queue.
            </summary>
            <param name="buffer">The content of the message.</param>
            <returns>True if the message is put into the send queue. False if the message is too large to fit in the send queue, or the transport is closed.</returns>
            <exception cref="T:System.ArgumentException">The size of the message is larger than 256 * mtu, thus it can not be correctly fragmented and sent. This exception is never thrown in stream mode.</exception>
            <exception cref="T:System.InvalidOperationException">The send or flush operation is initiated concurrently.</exception>
        </member>
        <member name="M:KcpSharp.KcpConversation.TrySend(System.ReadOnlySpan{System.Byte},System.Boolean,System.Int32@)">
            <summary>
            Try to put message into the send queue.
            </summary>
            <param name="buffer">The content of the message.</param>
            <param name="allowPartialSend">Whether partial sending is allowed in stream mode. This must not be true in non-stream mode.</param>
            <param name="bytesWritten">The number of bytes put into the send queue. This is always the same as the size of the <paramref name="buffer"/> unless <paramref name="allowPartialSend"/> is set to true.</param>
            <returns>True if the message is put into the send queue. False if the message is too large to fit in the send queue, or the transport is closed.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="allowPartialSend"/> is set to true in non-stream mode. Or the size of the message is larger than 256 * mtu, thus it can not be correctly fragmented and sent. This exception is never thrown in stream mode.</exception>
            <exception cref="T:System.InvalidOperationException">The send or flush operation is initiated concurrently.</exception>
        </member>
        <member name="M:KcpSharp.KcpConversation.WaitForSendQueueAvailableSpaceAsync(System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Wait until the send queue contains at least <paramref name="minimumBytes"/> bytes of free space, and also <paramref name="minimumSegments"/> available segments.
            </summary>
            <param name="minimumBytes">The number of bytes in the available space.</param>
            <param name="minimumSegments">The count of segments in the available space.</param>
            <param name="cancellationToken">The token to cancel this operation.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minimumBytes"/> or <paramref name="minimumSegments"/> is larger than the total space of the send queue.</exception>
            <exception cref="T:System.OperationCanceledException">The <paramref name="cancellationToken"/> is fired before send operation is completed. Or <see cref="M:KcpSharp.KcpConversation.CancelPendingSend(System.Exception,System.Threading.CancellationToken)"/> is called before this operation is completed.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that completes when there is enough space in the send queue. The result of the task is false when the transport is closed.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.SendAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Put message into the send queue.
            </summary>
            <param name="buffer">The content of the message.</param>
            <param name="cancellationToken">The token to cancel this operation.</param>
            <exception cref="T:System.ArgumentException">The size of the message is larger than 256 * mtu, thus it can not be correctly fragmented and sent. This exception is never thrown in stream mode.</exception>
            <exception cref="T:System.OperationCanceledException">The <paramref name="cancellationToken"/> is fired before send operation is completed. Or <see cref="M:KcpSharp.KcpConversation.CancelPendingSend(System.Exception,System.Threading.CancellationToken)"/> is called before this operation is completed.</exception>
            <exception cref="T:System.InvalidOperationException">The send or flush operation is initiated concurrently.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that completes when the entire message is put into the queue. The result of the task is false when the transport is closed.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.CancelPendingSend">
            <summary>
            Cancel the current send operation or flush operation.
            </summary>
            <returns>True if the current operation is canceled. False if there is no active send operation.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.CancelPendingSend(System.Exception,System.Threading.CancellationToken)">
            <summary>
            Cancel the current send operation or flush operation.
            </summary>
            <param name="innerException">The inner exception of the <see cref="T:System.OperationCanceledException"/> thrown by the <see cref="M:KcpSharp.KcpConversation.SendAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)"/> method or <see cref="M:KcpSharp.KcpConversation.FlushAsync(System.Threading.CancellationToken)"/> method.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> in the <see cref="T:System.OperationCanceledException"/> thrown by the <see cref="M:KcpSharp.KcpConversation.SendAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)"/> method or <see cref="M:KcpSharp.KcpConversation.FlushAsync(System.Threading.CancellationToken)"/> method.</param>
            <returns>True if the current operation is canceled. False if there is no active send operation.</returns>
        </member>
        <member name="P:KcpSharp.KcpConversation.UnflushedBytes">
            <summary>
            Gets the count of bytes not yet sent to the remote host or not acknowledged by the remote host.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpConversation.FlushAsync(System.Threading.CancellationToken)">
            <summary>
            Wait until all messages are sent and acknowledged by the remote host, as well as all the acknowledgements are sent.
            </summary>
            <param name="cancellationToken">The token to cancel this operation.</param>
            <exception cref="T:System.OperationCanceledException">The <paramref name="cancellationToken"/> is fired before send operation is completed. Or <see cref="M:KcpSharp.KcpConversation.CancelPendingSend(System.Exception,System.Threading.CancellationToken)"/> is called before this operation is completed.</exception>
            <exception cref="T:System.InvalidOperationException">The send or flush operation is initiated concurrently.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KcpSharp.KcpConversation"/> instance is disposed.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that completes when the all messages are sent and acknowledged. The result of the task is false when the transport is closed.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.InputPakcetAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpConversation.TryPeek(KcpSharp.KcpConversationReceiveResult@)">
            <summary>
            Get the size of the next available message in the receive queue.
            </summary>
            <param name="result">The transport state and the size of the next available message.</param>
            <exception cref="T:System.InvalidOperationException">The receive or peek operation is initiated concurrently.</exception>
            <returns>True if the receive queue contains at least one message. False if the receive queue is empty or the transport is closed.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.TryReceive(System.Span{System.Byte},KcpSharp.KcpConversationReceiveResult@)">
            <summary>
            Remove the next available message in the receive queue and copy its content into <paramref name="buffer"/>. When in stream mode, move as many bytes as possible into <paramref name="buffer"/>.
            </summary>
            <param name="buffer">The buffer to receive message.</param>
            <param name="result">The transport state and the count of bytes moved into <paramref name="buffer"/>.</param>
            <exception cref="T:System.ArgumentException">The size of the next available message is larger than the size of <paramref name="buffer"/>. This exception is never thrown in stream mode.</exception>
            <exception cref="T:System.InvalidOperationException">The receive or peek operation is initiated concurrently.</exception>
            <returns>True if the next available message is moved into <paramref name="buffer"/>. False if the receive queue is empty or the transport is closed.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.WaitToReceiveAsync(System.Threading.CancellationToken)">
            <summary>
            Wait until the receive queue contains at least one full message, or at least one byte in stream mode.
            </summary>
            <param name="cancellationToken">The token to cancel this operation.</param>
            <exception cref="T:System.OperationCanceledException">The <paramref name="cancellationToken"/> is fired before receive operation is completed.</exception>
            <exception cref="T:System.InvalidOperationException">The receive or peek operation is initiated concurrently.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that completes when the receive queue contains at least one full message, or at least one byte in stream mode. Its result contains the transport state and the size of the available message.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.WaitForReceiveQueueAvailableDataAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Wait until the receive queue contains at leat <paramref name="minimumBytes"/> bytes.
            </summary>
            <param name="minimumBytes">The minimum bytes in the receive queue.</param>
            <param name="cancellationToken">The token to cancel this operation.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minimumBytes"/> is a negative integer.</exception>
            <exception cref="T:System.OperationCanceledException">The <paramref name="cancellationToken"/> is fired before receive operation is completed.</exception>
            <exception cref="T:System.InvalidOperationException">The receive or peek operation is initiated concurrently.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that completes when the receive queue contains at least <paramref name="minimumBytes"/> bytes. The result of the task is false when the transport is closed.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.WaitForReceiveQueueAvailableDataAsync(System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Wait until the receive queue contains at leat <paramref name="minimumBytes"/> bytes, and also <paramref name="minimumSegments"/> segments.
            </summary>
            <param name="minimumBytes">The minimum bytes in the receive queue.</param>
            <param name="minimumSegments">The minimum segments in the receive queue</param>
            <param name="cancellationToken">The token to cancel this operation.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Any od <paramref name="minimumBytes"/> and <paramref name="minimumSegments"/> is a negative integer.</exception>
            <exception cref="T:System.OperationCanceledException">The <paramref name="cancellationToken"/> is fired before receive operation is completed.</exception>
            <exception cref="T:System.InvalidOperationException">The receive or peek operation is initiated concurrently.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that completes when the receive queue contains at least <paramref name="minimumBytes"/> bytes. The result of the task is false when the transport is closed.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.ReceiveAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Wait for the next full message to arrive if the receive queue is empty. Remove the next available message in the receive queue and copy its content into <paramref name="buffer"/>. When in stream mode, move as many bytes as possible into <paramref name="buffer"/>.
            </summary>
            <param name="buffer">The buffer to receive message.</param>
            <param name="cancellationToken">The token to cancel this operation.</param>
            <exception cref="T:System.ArgumentException">The size of the next available message is larger than the size of <paramref name="buffer"/>. This exception is never thrown in stream mode.</exception>
            <exception cref="T:System.OperationCanceledException">The <paramref name="cancellationToken"/> is fired before send operation is completed.</exception>
            <exception cref="T:System.InvalidOperationException">The receive or peek operation is initiated concurrently.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that completes when a full message is moved into <paramref name="buffer"/> or the transport is closed. Its result contains the transport state and the count of bytes written into <paramref name="buffer"/>.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.CancelPendingReceive">
            <summary>
            Cancel the current receive operation.
            </summary>
            <returns>True if the current operation is canceled. False if there is no active send operation.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.CancelPendingReceive(System.Exception,System.Threading.CancellationToken)">
            <summary>
            Cancel the current receive operation.
            </summary>
            <param name="innerException">The inner exception of the <see cref="T:System.OperationCanceledException"/> thrown by the <see cref="M:KcpSharp.KcpConversation.ReceiveAsync(System.Memory{System.Byte},System.Threading.CancellationToken)"/> method or <see cref="M:KcpSharp.KcpConversation.WaitToReceiveAsync(System.Threading.CancellationToken)"/> method.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> in the <see cref="T:System.OperationCanceledException"/> thrown by the <see cref="M:KcpSharp.KcpConversation.ReceiveAsync(System.Memory{System.Byte},System.Threading.CancellationToken)"/> method or <see cref="M:KcpSharp.KcpConversation.WaitToReceiveAsync(System.Threading.CancellationToken)"/> method.</param>
            <returns>True if the current operation is canceled. False if there is no active send operation.</returns>
        </member>
        <member name="M:KcpSharp.KcpConversation.SetTransportClosed">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpConversation.Dispose">
            <inheritdoc />
        </member>
        <member name="T:KcpSharp.KcpConversationOptions">
            <summary>
            Options used to control the behaviors of <see cref="T:KcpSharp.KcpConversation"/>.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.BufferPool">
            <summary>
            The buffer pool to rent buffer from.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.Mtu">
            <summary>
            The maximum packet size that can be transmitted over the underlying transport.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.SendWindow">
            <summary>
            The number of packets in the send window.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.ReceiveWindow">
            <summary>
            The number of packets in the receive window.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.RemoteReceiveWindow">
            <summary>
            The nuber of packets in the receive window of the remote host.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.UpdateInterval">
            <summary>
            The interval in milliseconds to update the internal state of <see cref="T:KcpSharp.KcpConversation"/>.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.NoDelay">
            <summary>
            Wether no-delay mode is enabled.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.FastResend">
            <summary>
            The number of ACK packet skipped before a resend is triggered.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.DisableCongestionControl">
            <summary>
            Whether congestion control is disabled.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.StreamMode">
            <summary>
            Whether stream mode is enabled.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.SendQueueSize">
            <summary>
            The number of packets in the send queue.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.ReceiveQueueSize">
            <summary>
            The number of packets in the receive queue.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.PreBufferSize">
            <summary>
            The number of bytes to reserve at the start of buffer passed into the underlying transport. The transport should fill this reserved space.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.PostBufferSize">
            <summary>
            The number of bytes to reserve at the end of buffer passed into the underlying transport. The transport should fill this reserved space.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.KeepAliveOptions">
            <summary>
            Options for customized keep-alive functionality.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationOptions.ReceiveWindowNotificationOptions">
            <summary>
            Options for receive window size notification functionality.
            </summary>
        </member>
        <member name="T:KcpSharp.KcpConversationReceiveResult">
            <summary>
            The result of a receive or peek operation.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationReceiveResult.BytesReceived">
            <summary>
            The number of bytes received.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpConversationReceiveResult.TransportClosed">
            <summary>
            Whether the underlying transport is marked as closed.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpConversationReceiveResult.#ctor(System.Int32)">
            <summary>
            Construct a <see cref="T:KcpSharp.KcpConversationReceiveResult"/> with the specified number of bytes received.
            </summary>
            <param name="bytesReceived">The number of bytes received.</param>
        </member>
        <member name="M:KcpSharp.KcpConversationReceiveResult.op_Equality(KcpSharp.KcpConversationReceiveResult,KcpSharp.KcpConversationReceiveResult)">
            <summary>
            Checks whether the two instance is equal.
            </summary>
            <param name="left">The one instance.</param>
            <param name="right">The other instance.</param>
            <returns>Whether the two instance is equal</returns>
        </member>
        <member name="M:KcpSharp.KcpConversationReceiveResult.op_Inequality(KcpSharp.KcpConversationReceiveResult,KcpSharp.KcpConversationReceiveResult)">
            <summary>
            Checks whether the two instance is not equal.
            </summary>
            <param name="left">The one instance.</param>
            <param name="right">The other instance.</param>
            <returns>Whether the two instance is not equal</returns>
        </member>
        <member name="M:KcpSharp.KcpConversationReceiveResult.Equals(KcpSharp.KcpConversationReceiveResult)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpConversationReceiveResult.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpConversationReceiveResult.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpConversationReceiveResult.ToString">
            <inheritdoc />
        </member>
        <member name="T:KcpSharp.KcpExceptionProducerExtensions">
            <summary>
            Helper methods for <see cref="T:KcpSharp.IKcpExceptionProducer`1"/>.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpExceptionProducerExtensions.SetExceptionHandler``1(KcpSharp.IKcpExceptionProducer{``0},System.Func{System.Exception,``0,System.Boolean})">
            <summary>
            Set the handler to invoke when exception is thrown. Return true in the handler to ignore the error and continue running. Return false in the handler to abort the operation.
            </summary>
            <param name="producer">The producer instance.</param>
            <param name="handler">The exception handler.</param>
        </member>
        <member name="M:KcpSharp.KcpExceptionProducerExtensions.SetExceptionHandler``1(KcpSharp.IKcpExceptionProducer{``0},System.Func{System.Exception,System.Boolean})">
            <summary>
            Set the handler to invoke when exception is thrown. Return true in the handler to ignore the error and continue running. Return false in the handler to abort the operation.
            </summary>
            <param name="producer">The producer instance.</param>
            <param name="handler">The exception handler.</param>
        </member>
        <member name="M:KcpSharp.KcpExceptionProducerExtensions.SetExceptionHandler``1(KcpSharp.IKcpExceptionProducer{``0},System.Action{System.Exception,``0,System.Object},System.Object)">
            <summary>
            Set the handler to invoke when exception is thrown.
            </summary>
            <param name="producer">The producer instance.</param>
            <param name="handler">The exception handler.</param>
            <param name="state">The state object to pass into the exception handler.</param>
        </member>
        <member name="M:KcpSharp.KcpExceptionProducerExtensions.SetExceptionHandler``1(KcpSharp.IKcpExceptionProducer{``0},System.Action{System.Exception,``0})">
            <summary>
            Set the handler to invoke when exception is thrown.
            </summary>
            <param name="producer">The producer instance.</param>
            <param name="handler">The exception handler.</param>
        </member>
        <member name="M:KcpSharp.KcpExceptionProducerExtensions.SetExceptionHandler``1(KcpSharp.IKcpExceptionProducer{``0},System.Action{System.Exception})">
            <summary>
            Set the handler to invoke when exception is thrown.
            </summary>
            <param name="producer">The producer instance.</param>
            <param name="handler">The exception handler.</param>
        </member>
        <member name="T:KcpSharp.KcpKeepAliveOptions">
            <summary>
            Options for customized keep-alive functionality.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpKeepAliveOptions.#ctor(System.Int32,System.Int32)">
            <summary>
            Create an instance of option object for customized keep-alive functionality.
            </summary>
            <param name="sendInterval">The minimum interval in milliseconds between sending keep-alive messages.</param>
            <param name="gracePeriod">When no packets are received during this period (in milliseconds), the transport is considered to be closed.</param>
        </member>
        <member name="T:KcpSharp.KcpMultiplexConnection`1">
            <summary>
            Multiplex many channels or conversations over the same transport.
            </summary>
            <typeparam name="T">The state of the channel.</typeparam>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.#ctor(KcpSharp.IKcpTransport)">
            <summary>
            Construct a multiplexed connection over a transport.
            </summary>
            <param name="transport">The underlying transport.</param>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.#ctor(KcpSharp.IKcpTransport,System.Action{`0})">
            <summary>
            Construct a multiplexed connection over a transport.
            </summary>
            <param name="transport">The underlying transport.</param>
            <param name="disposeAction">The action to invoke when state object is removed.</param>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.InputPakcetAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Process a newly received packet from the transport.
            </summary>
            <param name="packet">The content of the packet with conversation ID.</param>
            <param name="cancellationToken">A token to cancel this operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> that completes when the packet is handled by the corresponding channel or conversation.</returns>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.Contains(System.Int32)">
            <summary>
            Determine whether the multiplex connection contains a conversation with the specified id.
            </summary>
            <param name="id">The conversation ID.</param>
            <returns>True if the multiplex connection contains the specified conversation. Otherwise false.</returns>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.CreateRawChannel(System.Int32,KcpSharp.KcpRawChannelOptions)">
            <summary>
            Create a raw channel with the specified conversation ID.
            </summary>
            <param name="id">The conversation ID.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpRawChannel"/>.</param>
            <returns>The raw channel created.</returns>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Another channel or conversation with the same ID was already registered.</exception>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.CreateRawChannel(System.Int32,`0,KcpSharp.KcpRawChannelOptions)">
            <summary>
            Create a raw channel with the specified conversation ID.
            </summary>
            <param name="id">The conversation ID.</param>
            <param name="state">The user state of this channel.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpRawChannel"/>.</param>
            <returns>The raw channel created.</returns>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Another channel or conversation with the same ID was already registered.</exception>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.CreateConversation(System.Int32,KcpSharp.KcpConversationOptions)">
            <summary>
            Create a conversation with the specified conversation ID.
            </summary>
            <param name="id">The conversation ID.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpConversation"/>.</param>
            <returns>The KCP conversation created.</returns>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Another channel or conversation with the same ID was already registered.</exception>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.CreateConversation(System.Int32,`0,KcpSharp.KcpConversationOptions)">
            <summary>
            Create a conversation with the specified conversation ID.
            </summary>
            <param name="id">The conversation ID.</param>
            <param name="state">The user state of this conversation.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpConversation"/>.</param>
            <returns>The KCP conversation created.</returns>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Another channel or conversation with the same ID was already registered.</exception>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.RegisterConversation(KcpSharp.IKcpConversation,System.Int32)">
            <summary>
            Register a conversation or channel with the specified conversation ID and user state.
            </summary>
            <param name="conversation">The conversation or channel to register.</param>
            <param name="id">The conversation ID.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="conversation"/> is not provided.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Another channel or conversation with the same ID was already registered.</exception>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.RegisterConversation(KcpSharp.IKcpConversation,System.Int32,`0)">
            <summary>
            Register a conversation or channel with the specified conversation ID and user state.
            </summary>
            <param name="conversation">The conversation or channel to register.</param>
            <param name="id">The conversation ID.</param>
            <param name="state">The user state</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="conversation"/> is not provided.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Another channel or conversation with the same ID was already registered.</exception>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.UnregisterConversation(System.Int32)">
            <summary>
            Unregister a conversation or channel with the specified conversation ID.
            </summary>
            <param name="id">The conversation ID.</param>
            <returns>The conversation unregistered. Returns null when the conversation with the specified ID is not found.</returns>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.UnregisterConversation(System.Int32,`0@)">
            <summary>
            Unregister a conversation or channel with the specified conversation ID.
            </summary>
            <param name="id">The conversation ID.</param>
            <param name="state">The user state.</param>
            <returns>The conversation unregistered. Returns null when the conversation with the specified ID is not found.</returns>
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.SendPacketAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.SetTransportClosed">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpMultiplexConnection`1.Dispose">
            <inheritdoc />
        </member>
        <member name="T:KcpSharp.KcpRawChannel">
            <summary>
            An unreliable channel with a conversation ID.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.#ctor(KcpSharp.IKcpTransport,KcpSharp.KcpRawChannelOptions)">
            <summary>
            Construct a unreliable channel with a conversation ID.
            </summary>
            <param name="transport">The underlying transport.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpRawChannel"/>.</param>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.#ctor(KcpSharp.IKcpTransport,System.Int32,KcpSharp.KcpRawChannelOptions)">
            <summary>
            Construct a unreliable channel with a conversation ID.
            </summary>
            <param name="transport">The underlying transport.</param>
            <param name="conversationId">The conversation ID.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpRawChannel"/>.</param>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.SetExceptionHandler(System.Func{System.Exception,KcpSharp.KcpRawChannel,System.Object,System.Boolean},System.Object)">
            <summary>
            Set the handler to invoke when exception is thrown during flushing packets to the transport. Return true in the handler to ignore the error and continue running. Return false in the handler to abort the operation and mark the transport as closed.
            </summary>
            <param name="handler">The exception handler.</param>
            <param name="state">The state object to pass into the exception handler.</param>
        </member>
        <member name="P:KcpSharp.KcpRawChannel.ConversationId">
            <summary>
            Get the ID of the current conversation.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpRawChannel.TransportClosed">
            <summary>
            Get whether the transport is marked as closed.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.SendAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Send message to the underlying transport.
            </summary>
            <param name="buffer">The content of the message</param>
            <param name="cancellationToken">The token to cancel this operation.</param>
            <exception cref="T:System.ArgumentException">The size of the message is larger than mtu, thus it can not be sent.</exception>
            <exception cref="T:System.OperationCanceledException">The <paramref name="cancellationToken"/> is fired before send operation is completed.</exception>
            <exception cref="T:System.InvalidOperationException">The send operation is initiated concurrently.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KcpSharp.KcpConversation"/> instance is disposed.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that completes when the entire message is put into the queue. The result of the task is false when the transport is closed.</returns>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.CancelPendingSend">
            <summary>
            Cancel the current send operation or flush operation.
            </summary>
            <returns>True if the current operation is canceled. False if there is no active send operation.</returns>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.CancelPendingSend(System.Exception,System.Threading.CancellationToken)">
            <summary>
            Cancel the current send operation or flush operation.
            </summary>
            <param name="innerException">The inner exception of the <see cref="T:System.OperationCanceledException"/> thrown by the <see cref="M:KcpSharp.KcpRawChannel.SendAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)"/> method.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> in the <see cref="T:System.OperationCanceledException"/> thrown by the <see cref="M:KcpSharp.KcpRawChannel.SendAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)"/> method.</param>
            <returns>True if the current operation is canceled. False if there is no active send operation.</returns>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.InputPakcetAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpRawChannel.TryPeek(KcpSharp.KcpConversationReceiveResult@)">
            <summary>
            Get the size of the next available message in the receive queue.
            </summary>
            <param name="result">The transport state and the size of the next available message.</param>
            <exception cref="T:System.InvalidOperationException">The receive or peek operation is initiated concurrently.</exception>
            <returns>True if the receive queue contains at least one message. False if the receive queue is empty or the transport is closed.</returns>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.TryReceive(System.Span{System.Byte},KcpSharp.KcpConversationReceiveResult@)">
            <summary>
            Remove the next available message in the receive queue and copy its content into <paramref name="buffer"/>.
            </summary>
            <param name="buffer">The buffer to receive message.</param>
            <param name="result">The transport state and the count of bytes moved into <paramref name="buffer"/>.</param>
            <exception cref="T:System.ArgumentException">The size of the next available message is larger than the size of <paramref name="buffer"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The receive or peek operation is initiated concurrently.</exception>
            <returns>True if the next available message is moved into <paramref name="buffer"/>. False if the receive queue is empty or the transport is closed.</returns>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.WaitToReceiveAsync(System.Threading.CancellationToken)">
            <summary>
            Wait until the receive queue contains at least one message.
            </summary>
            <param name="cancellationToken">The token to cancel this operation.</param>
            <exception cref="T:System.OperationCanceledException">The <paramref name="cancellationToken"/> is fired before receive operation is completed.</exception>
            <exception cref="T:System.InvalidOperationException">The receive or peek operation is initiated concurrently.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that completes when the receive queue contains at least one full message, or at least one byte in stream mode. Its result contains the transport state and the size of the available message.</returns>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.ReceiveAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Wait for the next full message to arrive if the receive queue is empty. Remove the next available message in the receive queue and copy its content into <paramref name="buffer"/>.
            </summary>
            <param name="buffer">The buffer to receive message.</param>
            <param name="cancellationToken">The token to cancel this operation.</param>
            <exception cref="T:System.ArgumentException">The size of the next available message is larger than the size of <paramref name="buffer"/>.</exception>
            <exception cref="T:System.OperationCanceledException">The <paramref name="cancellationToken"/> is fired before send operation is completed.</exception>
            <exception cref="T:System.InvalidOperationException">The receive or peek operation is initiated concurrently.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that completes when a message is moved into <paramref name="buffer"/> or the transport is closed. Its result contains the transport state and the count of bytes written into <paramref name="buffer"/>.</returns>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.CancelPendingReceive">
            <summary>
            Cancel the current receive operation.
            </summary>
            <returns>True if the current operation is canceled. False if there is no active send operation.</returns>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.CancelPendingReceive(System.Exception,System.Threading.CancellationToken)">
            <summary>
            Cancel the current send operation or flush operation.
            </summary>
            <param name="innerException">The inner exception of the <see cref="T:System.OperationCanceledException"/> thrown by the <see cref="M:KcpSharp.KcpRawChannel.ReceiveAsync(System.Memory{System.Byte},System.Threading.CancellationToken)"/> method or <see cref="M:KcpSharp.KcpRawChannel.WaitToReceiveAsync(System.Threading.CancellationToken)"/> method.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> in the <see cref="T:System.OperationCanceledException"/> thrown by the <see cref="M:KcpSharp.KcpRawChannel.ReceiveAsync(System.Memory{System.Byte},System.Threading.CancellationToken)"/> method or <see cref="M:KcpSharp.KcpRawChannel.WaitToReceiveAsync(System.Threading.CancellationToken)"/> method.</param>
            <returns>True if the current operation is canceled. False if there is no active send operation.</returns>
        </member>
        <member name="M:KcpSharp.KcpRawChannel.SetTransportClosed">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpRawChannel.Dispose">
            <inheritdoc />
        </member>
        <member name="T:KcpSharp.KcpRawChannelOptions">
            <summary>
            Options used to control the behaviors of <see cref="T:KcpSharp.KcpRawChannelOptions"/>.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpRawChannelOptions.BufferPool">
            <summary>
            The buffer pool to rent buffer from.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpRawChannelOptions.Mtu">
            <summary>
            The maximum packet size that can be transmitted over the underlying transport.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpRawChannelOptions.ReceiveQueueSize">
            <summary>
            The number of packets in the receive queue.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpRawChannelOptions.PreBufferSize">
            <summary>
            The number of bytes to reserve at the start of buffer passed into the underlying transport. The transport should fill this reserved space.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpRawChannelOptions.PostBufferSize">
            <summary>
            The number of bytes to reserve at the end of buffer passed into the underlying transport. The transport should fill this reserved space.
            </summary>
        </member>
        <member name="T:KcpSharp.KcpReceiveWindowNotificationOptions">
            <summary>
            Options for sending receive window size notification.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpReceiveWindowNotificationOptions.#ctor(System.Int32,System.Int32)">
            <summary>
            Create an instance of option object for receive window size notification functionality.
            </summary>
            <param name="initialInterval">The initial interval in milliseconds of sending window size notification.</param>
            <param name="maximumInterval">The maximum interval in milliseconds of sending window size notification.</param>
        </member>
        <member name="P:KcpSharp.KcpReceiveWindowNotificationOptions.InitialInterval">
            <summary>
            The initial interval in milliseconds of sending window size notification.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpReceiveWindowNotificationOptions.MaximumInterval">
            <summary>
            The maximum interval in milliseconds of sending window size notification.
            </summary>
        </member>
        <member name="T:KcpSharp.KcpRentedBuffer">
            <summary>
            The buffer rented and owned by KcpSharp.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpRentedBuffer.Memory">
            <summary>
            The rented buffer.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpRentedBuffer.Span">
            <summary>
            The rented buffer.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpRentedBuffer.IsAllocated">
            <summary>
            Whether this struct contains buffer rented from the pool.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpRentedBuffer.IsEmpry">
            <summary>
            Whether this buffer contains no data.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.FromMemory(System.Memory{System.Byte})">
            <summary>
            Create the buffer from the specified <see cref="T:System.Memory`1"/>.
            </summary>
            <param name="memory">The memory region of this buffer.</param>
            <returns>The rented buffer.</returns>
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.FromSharedArrayPool(System.Int32)">
            <summary>
            Create the buffer from the shared array pool.
            </summary>
            <param name="size">The minimum size of the buffer required.</param>
            <returns>The rented buffer.</returns>
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.FromArrayPool(System.Buffers.ArrayPool{System.Byte},System.Byte[])">
            <summary>
            Create the buffer from the specified array pool.
            </summary>
            <param name="pool">The array pool to use.</param>
            <param name="buffer">The byte array rented from the specified pool.</param>
            <returns>The rented buffer.</returns>
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.FromArrayPool(System.Buffers.ArrayPool{System.Byte},System.ArraySegment{System.Byte})">
            <summary>
            Create the buffer from the specified array pool.
            </summary>
            <param name="pool">The array pool to use.</param>
            <param name="arraySegment">The byte array segment rented from the specified pool.</param>
            <returns>The rented buffer.</returns>
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.FromArrayPool(System.Buffers.ArrayPool{System.Byte},System.Int32)">
            <summary>
            Create the buffer from the specified array pool.
            </summary>
            <param name="pool">The array pool to use.</param>
            <param name="size">The minimum size of the buffer required.</param>
            <returns>The rented buffer.</returns>
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.FromMemoryOwner(System.Buffers.IMemoryOwner{System.Byte})">
            <summary>
            Create the buffer from the memory owner.
            </summary>
            <param name="memoryOwner">The owner of this memory region.</param>
            <returns>The rented buffer.</returns>
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.FromMemoryOwner(System.IDisposable,System.Memory{System.Byte})">
            <summary>
            Create the buffer from the memory owner.
            </summary>
            <param name="memoryOwner">The owner of this memory region.</param>
            <param name="memory">The memory region of the buffer.</param>
            <returns>The rented buffer.</returns>
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.Slice(System.Int32)">
            <summary>
            Forms a slice out of the current buffer that begins at a specified index.
            </summary>
            <param name="start">The index at which to begin the slice.</param>
            <returns>An object that contains all elements of the current instance from start to the end of the instance.</returns>
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the current memory starting at a specified index for a specified length.
            </summary>
            <param name="start">The index at which to begin the slice.</param>
            <param name="length">The number of elements to include in the slice.</param>
            <returns>An object that contains <paramref name="length"/> elements from the current instance starting at <paramref name="start"/>.</returns>
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.Dispose">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.Equals(KcpSharp.KcpRentedBuffer)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpRentedBuffer.ToString">
            <inheritdoc />
        </member>
        <member name="T:KcpSharp.KcpSocketTransport">
            <summary>
            Helper methods to create socket transports for KCP conversations.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport.CreateConversation(System.Net.Sockets.Socket,System.Net.EndPoint,System.Int32,KcpSharp.KcpConversationOptions)">
            <summary>
            Create a socket transport for KCP covnersation.
            </summary>
            <param name="socket">The socket instance.</param>
            <param name="endPoint">The remote endpoint.</param>
            <param name="conversationId">The conversation ID.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpConversation"/>.</param>
            <returns>The created socket transport instance.</returns>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport.CreateConversation(System.Net.Sockets.Socket,System.Net.EndPoint,KcpSharp.KcpConversationOptions)">
            <summary>
            Create a socket transport for KCP covnersation with no conversation ID.
            </summary>
            <param name="socket">The socket instance.</param>
            <param name="endPoint">The remote endpoint.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpConversation"/>.</param>
            <returns>The created socket transport instance.</returns>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport.CreateRawChannel(System.Net.Sockets.Socket,System.Net.EndPoint,System.Int32,KcpSharp.KcpRawChannelOptions)">
            <summary>
            Create a socket transport for raw channel.
            </summary>
            <param name="socket">The socket instance.</param>
            <param name="endPoint">The remote endpoint.</param>
            <param name="conversationId">The conversation ID.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpRawChannel"/>.</param>
            <returns>The created socket transport instance.</returns>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport.CreateRawChannel(System.Net.Sockets.Socket,System.Net.EndPoint,KcpSharp.KcpRawChannelOptions)">
            <summary>
            Create a socket transport for raw channel with no conversation ID.
            </summary>
            <param name="socket">The socket instance.</param>
            <param name="endPoint">The remote endpoint.</param>
            <param name="options">The options of the <see cref="T:KcpSharp.KcpRawChannel"/>.</param>
            <returns>The created socket transport instance.</returns>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport.CreateMultiplexConnection(System.Net.Sockets.Socket,System.Net.EndPoint,System.Int32)">
            <summary>
            Create a socket transport for multiplex connection.
            </summary>
            <param name="socket">The socket instance.</param>
            <param name="endPoint">The remote endpoint.</param>
            <param name="mtu">The maximum packet size that can be transmitted over the socket.</param>
            <returns></returns>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport.CreateMultiplexConnection``1(System.Net.Sockets.Socket,System.Net.EndPoint,System.Int32)">
            <summary>
            Create a socket transport for multiplex connection.
            </summary>
            <typeparam name="T">The type of the user state.</typeparam>
            <param name="socket">The socket instance.</param>
            <param name="endPoint">The remote endpoint.</param>
            <param name="mtu">The maximum packet size that can be transmitted over the socket.</param>
            <returns></returns>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport.CreateMultiplexConnection``1(System.Net.Sockets.Socket,System.Net.EndPoint,System.Int32,System.Action{``0})">
            <summary>
            Create a socket transport for multiplex connection.
            </summary>
            <typeparam name="T">The type of the user state.</typeparam>
            <param name="socket">The socket instance.</param>
            <param name="endPoint">The remote endpoint.</param>
            <param name="mtu">The maximum packet size that can be transmitted over the socket.</param>
            <param name="disposeAction">The action to invoke when state object is removed.</param>
            <returns></returns>
        </member>
        <member name="T:KcpSharp.KcpSocketTransportForConversation">
            <summary>
            Socket transport for KCP conversation.
            </summary>
        </member>
        <member name="T:KcpSharp.KcpSocketTransport`1">
            <summary>
            A Socket transport for upper-level connections.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport`1.#ctor(System.Net.Sockets.Socket,System.Net.EndPoint,System.Int32)">
            <summary>
            Construct a socket transport with the specified socket and remote endpoint.
            </summary>
            <param name="socket">The socket instance.</param>
            <param name="endPoint">The remote endpoint.</param>
            <param name="mtu">The maximum packet size that can be transmitted.</param>
        </member>
        <member name="P:KcpSharp.KcpSocketTransport`1.Connection">
            <summary>
            Get the upper-level connection instace. If Start is not called or the transport is closed, <see cref="T:System.InvalidOperationException"/> will be thrown.
            </summary>
            <exception cref="T:System.InvalidOperationException">Start is not called or the transport is closed.</exception>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport`1.Activate">
            <summary>
            Create the upper-level connection instance.
            </summary>
            <returns>The upper-level connection instance.</returns>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport`1.AllocateBuffer(System.Int32)">
            <summary>
            Allocate a block of memory used to receive from socket.
            </summary>
            <param name="size">The minimum size of the buffer.</param>
            <returns>The allocated memory buffer.</returns>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport`1.HandleException(System.Exception)">
            <summary>
            Handle exception thrown when receiving from remote endpoint.
            </summary>
            <param name="ex">The exception thrown.</param>
            <returns>Whether error should be ignored.</returns>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport`1.Start">
            <summary>
            Create the upper-level connection and start pumping packets from the socket to the upper-level connection.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport`1.SendPacketAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpSocketTransport`1.Dispose(System.Boolean)">
            <summary>
            Dispose all the managed and the unmanaged resources used by this instance.
            </summary>
            <param name="disposing">If managed resources should be disposed.</param>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport`1.Finalize">
            <summary>
            Dispose the unmanaged resources used by this instance.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpSocketTransport`1.Dispose">
            <inheritdoc />
        </member>
        <member name="T:KcpSharp.KcpStream">
            <summary>
            A stream wrapper of <see cref="T:KcpSharp.KcpConversation"/>.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpStream.#ctor(KcpSharp.KcpConversation,System.Boolean)">
            <summary>
            Create a stream wrapper over an existing <see cref="T:KcpSharp.KcpConversation"/> instance.
            </summary>
            <param name="conversation">The conversation instance. It must be in stream mode.</param>
            <param name="ownsConversation">Whether to dispose the <see cref="T:KcpSharp.KcpConversation"/> instance when <see cref="T:KcpSharp.KcpStream"/> is disposed.</param>
        </member>
        <member name="P:KcpSharp.KcpStream.CanRead">
            <inheritdoc />
        </member>
        <member name="P:KcpSharp.KcpStream.CanSeek">
            <inheritdoc />
        </member>
        <member name="P:KcpSharp.KcpStream.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:KcpSharp.KcpStream.Length">
            <summary>
            The length of the stream. This always throws <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:KcpSharp.KcpStream.Position">
            <summary>
            The position of the stream. This always throws <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="M:KcpSharp.KcpStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="P:KcpSharp.KcpStream.DataAvailable">
            <summary>
            Indicates data is available on the stream to be read. This property checks to see if at least one byte of data is currently available
            </summary>
        </member>
        <member name="M:KcpSharp.KcpStream.Flush">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.ReadByte">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.WriteByte(System.Byte)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.DisposeAsync">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.Read(System.Span{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:KcpSharp.KcpStream.Write(System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
    </members>
</doc>
